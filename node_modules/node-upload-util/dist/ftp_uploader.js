(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "ftp", "fs", "path", "rxjs", "./base_uploader", "./util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FtpUploader = void 0;
    const tslib_1 = require("tslib");
    const Client = require("ftp");
    const fs = require("fs");
    const path = require("path");
    const rxjs_1 = require("rxjs");
    const base_uploader_1 = require("./base_uploader");
    const util_1 = require("./util");
    class FtpUploader extends base_uploader_1.BaseUploader {
        initOptions(options) {
            this.options = options;
        }
        connect() {
            return new Promise((resolve) => {
                this.client = new Client();
                this.client.connect({
                    host: this.options.host,
                    port: this.options.port,
                    user: this.options.user,
                    password: this.options.password
                });
                rxjs_1.fromEvent(this.client, 'ready').subscribe(() => {
                    this.onReady();
                    resolve();
                });
                rxjs_1.fromEvent(this.client, 'error').subscribe((e) => {
                    throw new Error(e);
                });
            });
        }
        upload(filePath, destPath) {
            return new Promise((resolve, reject) => {
                const clientCb = (error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(filePath);
                    }
                };
                if (fs.statSync(filePath).isDirectory()) {
                    this.client.mkdir(destPath, true, clientCb);
                }
                else {
                    this.client.put(fs.readFileSync(filePath), destPath, false, clientCb);
                }
            });
        }
        startUpload() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const parsedFiles = util_1.parseFiles(this.options.files);
                    const getRealPath = (filePath) => path.join(this.options.rootPath || process.cwd(), filePath);
                    const getDestPath = (filePath) => path.posix.join(this.options.destRootPath, filePath);
                    this.onStart(parsedFiles);
                    for (const filePath of parsedFiles) {
                        yield this.upload(getRealPath(filePath), getDestPath(filePath));
                        this.onFileUpload(filePath, parsedFiles);
                    }
                    this.client.destroy();
                    this.onSuccess(parsedFiles);
                }
                catch (error) {
                    this.client.destroy();
                    this.onFailure(error);
                }
            });
        }
        onDestoryed() {
            if (this.client) {
                this.client = null;
                super.onDestoryed();
            }
        }
    }
    exports.FtpUploader = FtpUploader;
});
